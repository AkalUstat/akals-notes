{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Akal's Notes","text":"<p>Akal is a CS Student at CSUS. He tries to study but fails. Don't be like him.</p> <p>But here's his poor attempt at notes.</p>"},{"location":"#fall-2023-semester","title":"Fall 2023 Semester","text":"<ul> <li>CSC 35 - \u00a0Introduction to Computer Architecture (Assembly)</li> <li>CSC 28 - \u00a0Discrete Structures for Computer Science</li> <li>PHYS 11A - General Physics: Mechanics</li> </ul>"},{"location":"CSUS/Fall%2023/CSC%2028/Week%201/","title":"Week 1","text":""},{"location":"CSUS/Fall%2023/CSC%2028/Week%201/#1","title":"1.","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/","title":"Part I   Data and Memory","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/#1-binary-numbers","title":"1. Binary Numbers","text":"<p>The binary number system is base 2 and features only two digits: 0 and 1. </p> <p>To write a number in binary (from decimal), we use the following table:</p> \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 - - - - - - - - <p>Bit: one binary digit. 1 or 0. shorthand is \"b\".</p> <p>Byte: a group of 8 bits. shorthand is \"B\".</p> <p>Nibble: half of a byte or 4 bits. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/#hexadecimal-numbers","title":"Hexadecimal Numbers","text":"<p>Since binary numbers are cumbersome and error prone to write, especially with higher numbers of digits, computer scientists have come up with the hexadecimal system to store binary information. Since the hexadecimal system is base 16, one hexadecimal digit is equivalent to 4 bits. (\\(2^4 = 16\\))</p> Hex Decimal Binary Hex Decimal Binary 0 0 0000 8 8 1000 1 1 0001 9 9 1001 2 2 0010 A 10 1010 3 3 0011 B 11 1011 4 4 0100 C 12 1100 5 5 0101 D 13 1101 6 6 0110 E 14 1110 7 7 0111 F 15 1111"},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/#2-how-text-is-stored","title":"2. How Text is Stored","text":"<p>Since computers need to often store and transmit text data, it stores individual symbols as \"characters\", or rather the integer representation of each character. This integer representation is based on the \"standard\" being used, e.g., ASCII (7 bits) or UTF-8 (21 bits).</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/#ascii-tips-and-tricks","title":"Ascii Tips and Tricks","text":"<p>Each character has a unique value in the ASCII system, but it has its interesting quirks. For example, for alphabetic characters, upper and lowercase values are only 32 points apart. This means that to convert an uppercase letter to a lowercase letter, simple add 32 to its code - or rather \\(2^5\\), so this means just change the \\(2^5\\) place in the binary representation. </p> <p>To change number characters between the character code itself and the binary representation: - Character \\(\\rightarrow\\) Binary: Clear the upper nibble (set it to 0000) - Binary \\(\\rightarrow\\) Character: Set the upper nibble to 0011</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%201/Part%20I%20-%20Data%20and%20Memory/#3-computer-memory","title":"3. Computer Memory","text":"<p>Memory is basically an array. That's it. That's all. It's also referred to as storage and it stores both running programs and their related data together. </p> <p></p> <p>Memory is divided into storage locations that each hold 1 byte (8 bits). Each of these can be accessed using a unique identifier referred to as an address (basically the array index). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/","title":"1. What are Processors?","text":"<p>The Central Processing Unit (CPU) is the computer. While there are thousands of versions, each functioning differently (based on the paradigm of form follows function), all of them share the basic building blocks. </p> <p>There are two parts to a CPU: 1. Control Logic Unit (CLU) 2. Execution Unit (EU)</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#a-clu","title":"A. CLU","text":"<p>This part controls the processor. It determines when instructions can be executed. It controls internal operations, such as fetching and decoding instructions, while remaining invisible to running programs.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#b-eu","title":"B. EU","text":"<p>This part contains the physical hardware that executes tasks. Often modern processors will use many of them in parallel execution.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#alu","title":"ALU","text":"<p>The Arithmetic Logic Unit is part of the EU and performs all calculations and comparisons, including special hardware for integer and floating point. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#2-registers","title":"2. Registers","text":"<p>Since assembly does not have the concept of variables, we use registers, or physical locations on the processor itself, to store temporary data. Some are accessible to programs and others are hidden. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#why-registers","title":"Why registers?","text":"<p>Registers are designed to be quickly accessible (due to limitations in accessing memory) for anything the processor needs to keep track of.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#a-general-purpose-registers-gpr","title":"A. General Purpose Registers (GPR)","text":"<p>These registers are designed to be used by programs as needed (often calculations). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#b-special-registers","title":"B. Special Registers","text":"<p>These registers are unaccessible by programs and are instead used by the CLU, such as for control memory usage, program execution thread, etc, etc.</p> <p>Instruction Pointer (IP or Program Counter): This register keeps track of running program's address (like a line number). </p> <p>Status Register: This register contains boolean information about the processor's current state.</p> <p>Instruction Register (IR): This register stores the current instruction being executed.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#c-register-files","title":"C. Register Files","text":"<p>All related registers are grouped into a register file, although to to access and use these files depends on the processor. Sometimes registers are implied or hardwired. </p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#3-instructions","title":"3. Instructions","text":"<p>Assembly does not have the same constructs, e.g., Blocks, If Statements, While Statements, etc etc., as higher level languages, thus we are not abstracted from the architecture of the machine. Since we are on the architecture level, we can only perform series of simple tasks, or instructions. </p> <p>These instructions create all the logic needed by a program. The instructions supported by a processor is defined by the instruction set: - add two values together - copy a value - jump to memory location - etc</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#4-the-intel-x64","title":"4. The Intel x64","text":"<p>The x64 is the modern, Intel 64-bit processor platform that has been developed continuously over 40 years.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#a-the-og-x86","title":"A. The OG: x86","text":"<p>The x86 was originally 16-bit when it was released in 1978. It featured 16, 16-bit registers. It was then expanded to 32-bit under the \"x86\" moniker. For the 64-bit transition, it was renamed \"x64\".</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#x86-registers","title":"x86 Registers","text":"<p>The original x86 featured 16 registers, 8 of which were open-access and 8 which were hidden, used for memory management. </p> <ul> <li>4 GPR: AX, BX, CX, DX</li> <li>4 Pointer Index: SI, DI, BP, SP</li> <li>Restricted 8: CS, DS, ES, FS, GS, SS + IP + Status Register</li> </ul>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#32-bit-evolution","title":"32-bit Evolution","text":"<p>Old registers obtained the \"e\" (for extended) suffix for their 32-bit versions. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#64-bit-evolution","title":"64-bit Evolution","text":"<p>Registers obtained the \"r\" prefix for their 64-bit versions and added 8-additional registers. For hardware consistency, it was possible to get 8-bit values from all registers.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#64-bit-register-table","title":"64-bit Register Table","text":"64-bit 32-bit 16-bit 8-bit High 8-bit Low rax eax ax ah al rbx ebx bx bh bl rcx ecx cx ch cl rdx edx dx dh dl rsi esi si sil rdi edi di dil rbp ebp bp bpl rsp esp sp spl r8 r8d r8w r8b r9 r9d r9w r9b r10 r10d r10w r10b r11 r11d r11w r11b r12 r12d r12w r12b r13 r13d r13w r13b r14 r14d r14w r14b r15 r15d r15w r15b"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#4-basic-intel-x86-instructions","title":"4. Basic Intel x86 Instructions","text":"<p>Each instruction in x86 can have up to 2 operands, which are very versatile in that they can either be a memory address, register, or an immediate value (constant), although certain instructions have limitations on which can be used. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#limitations","title":"Limitations","text":"<ul> <li>a register must always be involved (both operands cannot access memory at the same time)</li> <li>the receiving field cannot be an immediate value</li> </ul>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#a-move-instruction","title":"A. Move Instruction","text":"<p>The Intel Move Instruction combines transfer, load, and store instructions. It copies data.</p> <pre><code>MOV destination, source\n\n# destination is a register or memory\n# source is immediate, register, or memory\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#b-add-and-subtract","title":"B. Add and Subtract","text":"<pre><code>ADD, target, value\n\n# target is register or memory\n# value is immediate, register, or memory\n\nSUB target, value\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#c-and-and-or","title":"C. AND and OR","text":"<pre><code>AND target, value\n\n# target is register or memory\n# value is immediate, register, or memory\n\nOR target, value\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%202/Part%202%20-%20Processors/#d-call","title":"D. Call","text":"<p>Tells the processor to start a subroutine (covered in later parts). Returns to current line after call. </p> <pre><code>CALL address\n\n# address is either the address itself or a label\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/","title":"1. Compilers, Assemblers, and Linkers","text":"<p>When you hit \"compile\" or \"run\" many things happen in the background. </p> <p>The Development Process:  1. Write program in high-level language 2. Compile program into assembly 3. Assemble program into objects 4. Link multiple objects programs into one executable 5. Load executable into memory 6. Execute it</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#a-your-code-to-binary","title":"A. Your Code to Binary","text":"<p>At the base level, when we are editing code in a Code Editor, where we get type-checking and other features, that functionality is provided by an Interpreter, which never compiles the code, but run parts of their own program.</p> <p>A compiler converts programs from high-level languages into assembly language.</p> <p>From this compiled program, an assembler converts assembly into binary readable by the processor. This results in an object file, which is not executable at this point. It contains instructions and information on how to link into other executable \"units\".</p> <p>Often, since parts of a program are created separately (executable \"units\" or objects). A linker joins them into a single file. It connects labels from the object that defines it to the one that uses it. (One object can call another). </p> <p>The Unix headers crt1.o and crti.o (automatically supplied) reference a subroutine called <code>_start</code>, provided by your own program.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#2-assembly-basics","title":"2. Assembly Basics","text":"<p>Assembly programs allow you to write machine language programs in easy-to-read text. Assembly varies based on specific processor architecture (does not \"cross-port\").</p> <p>Assembly Benefits: 1. Consistent way of writing instructions 2. Automatically count bytes and allocates buffers 3. Labels are used to keep track of addresses</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#i-consistent-instructions","title":"I. Consistent Instructions","text":"<p>Assembly combines related machine instructions into a single notation (and name) called a mnemonic.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#ii-count-and-allocate-buffers","title":"II. Count and Allocate Buffers","text":"<p>Assembly automatically counts bytes and allocates buffers (since miscounts done by hand are common). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#iii-labels-and-addresses","title":"III. Labels and Addresses","text":"<p>Addresses are stored using labels (nice, easy to use names for addresses). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#a-syntaxes","title":"A. Syntaxes","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#i-att-syntax","title":"I. AT&amp;T Syntax","text":"<ul> <li>Unix and Linux dominance</li> <li>registers prefixed by '%' and values with '$'</li> <li>receiving register is last</li> </ul>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#ii-intel-syntax","title":"II. Intel Syntax","text":"<ul> <li>Created by MS</li> <li>dominant on DOS/Windows</li> <li>neither registers or values have a prefix</li> <li>receiving register is first</li> </ul>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#3-assembly-program-structure","title":"3. Assembly Program Structure","text":"<p>There are two parts to an assembly program, the data and text section.</p> <p>Data Section: allocates bytes to store constants, variables, etc </p> <p>Text Section: contains the instructions that will make up the program.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#a-the-data-section","title":"A. The Data Section","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#i-directives","title":"I. Directives","text":"<p>A directive is a special command for the assembler. It starts with a \".\"</p> <p>They can: - allocate space - define constants - start the text/data section - make labels \"global\" for the linker</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#ii-labels","title":"II. Labels","text":"<p>Labels are defined by an identifier followed by a colon. When an assembler sees a label declaration, it saves the current address into a table of labels stored in the object file. Labels are addresses. Labels also do not generate any bytes in the final machine code.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#4-unix-basics","title":"4. Unix Basics","text":"<p>Unix was developed at AT&amp;T's Bell Labs in 1969 and was designed for mainframes and to be stable/powerful. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#a-command-line-interfaces","title":"A. Command Line Interfaces","text":"<p>Since Unix was developed before GUIs, all interaction with the computer was done through command line interfaces (CLIs). This interface is text only but performs the same commands as GUIs.</p> <p>Each command starts with a name followed by arguments which are separated by spaces. </p> <p><pre><code>name argument1 argument2\n</code></pre> Some UNIX Commands: - <code>ls</code>: List all files in CWD - <code>ll</code>: List Long. Shortcut for <code>ls -l</code> - <code>pwd</code>: Print Working Directory. Prints out your current path. - <code>cd</code>: Change Directory. - <code>mkdir</code>: Make Directory. - <code>rm</code>: Remove. Deletes a file. There is no way to recover this file. - <code>nano</code>: a UNIX text editor.  - <code>as</code>: GNU assembler. Converts an assembly program into an object. It will alert you of any syntax errors or unrecognized mnemonics (typos). The command is written as follows: <pre><code>as -o lab.o lab.asm\n</code></pre> The -o specifies that the next name listed is the output file. The third argument is the input file. - <code>ld</code>: GNU linker. Takes 1+ objects and links them into an executable. Any unresolved labels will be brought to your attention. The command is written as follows: <pre><code>ld -o a.out csc35.2 lab.o\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#5-machine-language","title":"5. Machine Language","text":"<p>Eventually, your programs are broken down into their raw binary form, called Machine Language or Machine Code.</p> <p>Each instruction in your program is encoded into a compact binary format. It is easier for the processor to interpret and execute this encoding. However, not all encodings are equal: some instructions require more bytes than others. </p> <p>Each instruction must contain everything the processor needs to know to do something (like functions in java: they need a name and arguments). Thus, each instruction has a unique Operation Code (Opcode) that specifies the exact operation to be performed by the processor. In assembly, we use friendly names for these called mnemonics. The opcode is followed by various operands (data to be used in the operation). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%203/Part%203%20-%20Programs/#a-encoding","title":"A. Encoding","text":"<p>Since x64 encoding is complex, we will use a fictitious processor called the Herky 6000 Processor, which mirrors the Intel behavior but is easier to encode. Its specifications are: - each instruction is 24-bit (3 byte) - 16 GPR (using Intel names) - supports all major addressing modes - most instruction fields line up cleanly on each nibble \\(\\rightarrow\\) each hex digit is a field</p> <p></p> <p></p> <p>Since instructions oft need to store an immediate, the Herky Processor allows the second operand to store the byte count (\\(2^n\\), where \\(n = 0,1,2,3,4\\)).</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/","title":"1. Buffers","text":"<p>A buffer is any allocated block of memory that contains data (e.g., text, image, file, etc). There are several assembly directives which allocate space, a few of which we have covered: </p> Directive Purpose <code>.ascii</code> Allocate enough space to store an ASCII string. <code>.quad</code> Allocate 8-byte blocks with initial value(s). <code>.byte</code> Allocate byte(s) with initial values. <code>.space</code> Allocate any size of empty bytes (with initial values)."},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#2-addressing-modes","title":"2. Addressing Modes","text":"<p>Processors often need to access memory to read values and store results. We've done the basics of reading and storing single values using registers so far, but we need to do more complex things such as: - access items in an array - follow pointers - etc</p> <p>How the processor can go about reading and writing that data is called an addressing mode. There are 4 basic modes: - Immediate Addressing - Register Addressing - Direct Addressing - Indirect Addressing</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#i-immediate-addressing","title":"I. Immediate Addressing","text":"<p>An immediate is a constant value often stored as part of an instruction. Thus, it is immediately available. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#ii-register-addressing","title":"II. Register Addressing","text":"<p>Register addressing is used in almost all computer instructions, where a value is read from or stored into one of the registers. </p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#iii-relative-addressing","title":"III. Relative Addressing","text":"<p>We can also use relative addressing by adding a value to the IP/Program Counter. This means that the instruction can just store the difference from the current instruction address (takes less storage than a full 64-bit address). This allows a program to be stored anywhere in memory and still work.</p> <p>This way of storing addresses is often used in jump statements and to access local data (load/store).</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#iv-direct-addressing","title":"IV. Direct Addressing","text":"<p>In direct addressing, the processor reads data directly from an address. This commonly used to get a value from a \"variable\" or read items in an array.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#v-register-indirect-addressing","title":"V. Register Indirect Addressing","text":"<p>Register indirect reads data from an address stored in a register (like pointers). It's just as fast as direct addressing and with the benefit that the processor already has the address. Register indirect requires square brackets. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#3-sizing-instructions","title":"3. Sizing Instructions","text":"<p>Intel can load/store 1-, 2-, 4-, or 8- byte values. The assembler differentiates between them by looking at the size of the register. However, sometimes, the number of bytes can't be determined (such as loading from or writing into memory). In this case, it will report as an error since it cannot properly encode the instruction.</p> <p>To deal with the \"ambiguous operand size error\", the GAS assembler allows us to place a single character after the mnemonic to tell it how many bytes will be processed during the operation. </p> Suffix Name Size <code>b</code> byte 1 byte <code>s</code> short 2 bytes <code>l</code> long 4 bytes <code>q</code> quad 8 bytes"},{"location":"CSUS/Fall%2023/CSC35/Part%204/Part%204%20-%20Addressing/#4-endianess","title":"4. Endianess","text":"<p>On a 64-bit system, the word, or the byte-size of each basic piece of data, is 8 bytes. So, when we store something, we need to use all 8 bytes. But in what order do we store them?</p> <p>In the Big Endian approach, we store the Most Significant Byte (MSB) first. In the Little Endian approach, we store the Least Significant Byte (LSB) first.</p> <p>This is important since if two systems (the system that wrote the data and the one that reads the data) use different formats, the data will be interpreted incorrectly (as hopelessly mangled junk most of the time). So, we cannot assume that data accessed from secondary storage or any file format will match the processor's format.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%205/Part%205%20-%20Indexing/","title":"1. Arrays: Behind the Scenes","text":"<p>Since computers don't have an array data type, they allocate a block of memory and then each element is located sequentially within the block. We store the base index and then compute the address of the nth element. </p> <pre><code>icon: file\ntitle: Example Array in Memory\n| Location | Value | \n| --- | --- |\n| 2000 | F0A3 |\n| 2002 | 042B | \n| 2004 | c1F1 |\n| 2006 | 0D0B |\n| 2008 | 9C2A |\n</code></pre> <p>The mathematical formula for accessing these individual values is \\(address_{start} + (index * size)\\) and is why C- and C-inspired languages use a zero-index based array system. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%205/Part%205%20-%20Indexing/#indexing-on-the-x64","title":"Indexing on the x64","text":"<p>The x64 supports direct, indirect, and scaling addressing. Processors create the effective address, or an address programmatically generated for accessing memory,  for a value using the above mentioned formula. In the Intel x64 syntax, it is written as: $$ [Base + Index \\cdot Scale + Displacement] $$ The terms are defined as below: - Base: (register) initial address. - Displacement: (constant)\"offset\". A constant (immediate) added to the address. - Index: (register/constant) a register added to the address. - Scale: (constant) used to multiply the index before adding it to the address.</p> <pre><code>title: Base vs. Displacement?\n\nThe \"displacement\" is used in Direct Addressing (since we are using a constant, signed integer) and the \"base\" is used in indirect addressing (since we use a register). \n\n&amp;ensp;\n\nBoth can be used together but this is not covered in this class.\n</code></pre> <p>This finishes our addressing mode table from earlier.</p> Mode Syntax Java Equivalent Immediate value value Register register register Direct label Memory [label] Direct (Indexed) [label + reg] Memory [label + reg] Indirect [reg] Memory [reg] Indirect (Indexed) [reg + reg] Memory [reg + reg] Indirect (Indexed + Scaled) [reg + reg * scale] Memory[reg + reg * scale] <p>When doing any of these formats, all four parts of the formula are being used, but \"missing\" items are filled in. </p> <pre><code>title: For Further Examples\nFor further examples, view Devin Cook's Part 5 Lecture Slide, slides 23-29.\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%205/Part%205%20-%20Indexing/#2-tables-organizing-data","title":"2. Tables: Organizing Data","text":"<p>Tables can contain any type of data and are accessed using scaling indexing (discussed in  #1. Arrays: Behind the Scenes). </p> <pre><code>icon: file\ntitle: Creating a Table of Long Integers\n\nCreating the table:\n~~~asm6502\nYears:\n    .quad 1776\n    .quad 1783\n    .quad 1846\n    .quad 1850\n    .quad 1947\n~~~\n\nAccessing the table:\n~~~asm6502\nmov rsi, 1\nmov rcx, [Years + rsi * 8]\n~~~\n</code></pre> <pre><code>icon: file\ntitle: A Table of Strings\n\nCreating the table:\n~~~asm6502\nSutter:\n    .ascii \"John Sutter\\0\"\nMarshal:\n    .ascii \"James Marshal\\0\"\nNames:\n    .quad Sutter\n    .quad Marshal\n~~~\n\nAccessing the table:\n~~~asm6502\nmov rsi, 1\nmov rdi, [Names + rsi * 8]\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%205/Part%205%20-%20Indexing/#encoding-indexes-in-herkey","title":"Encoding Indexes in Herkey","text":"<p>The following example code will be used for this section: <pre><code>(1) LDR r4, [42 + r5 * 8]\n(2) LDR r4, [r7 + r5 * 8]\n</code></pre></p> <p>Herkey Direct (Line 1) </p> <p>Herkey Indirect (Line 2) </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%205/Part%205%20-%20Indexing/#3-buffer-overflows-great-responsibility","title":"3. Buffer Overflows: Great Responsibility","text":"<p>Operating systems do a good job of projecting programs from being damaged by other programs, but not as good of a job protecting themselves. Data is often stored next to the instructions, and it is possible to store too much information, which overflows out of the buffer and overwrites part of the running program. </p> <p>It is possible to do this by accident in an assembly program as well, since we have full control. </p> <pre><code>title: For Illustration\nSee Devin Cook's Part 5 Lecture Slide, slides 49-51\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/","title":"1. x86 Jump Instructions: Mario Time","text":"<p>Since assembly does not provide high-level expressions or blocks, we have to jump over code to implement this logic. The processor achieves this by moving the Instruction Pointer (discussed in Part 2) to a new address and continuing execution. </p> <p>There are many types of jumps.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#unconditional-jumps","title":"Unconditional Jumps","text":"<p>This is a simple transferring of a program to a new address (a la <code>goto</code>).</p> <pre><code>JMP address\n</code></pre> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#conditional-jumps","title":"Conditional Jumps","text":"<p>Conditional jumps will, as the name suggests, only jump if a certain condition is met. This is used to implement branching logic. In order to do this, we first must use a comparison statement to determine if we can or will jump.</p> <p><pre><code>CMP arg1, arg2\n\n# arg1 = register or memory\n# arg2 = immediate, register, or memory\n</code></pre> </p> <p>There are many conditional jump statements for readability. </p> Jump Description <code>je</code> Jump Equal <code>jne</code> Jump Not Equal <code>jg</code> Jump Greater than <code>jge</code> Jump Greater than or Equal <code>jl</code> Jump Less than <code>jle</code> Jump Less than or Equal <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#2-if-statements-on-the-x86","title":"2. If Statements on the x86","text":"<p>To make this simpler (and use less LOC), in assembly, we will reverse the logic of the <code>if</code> statement. If we pass the test condition, we will continue to execute downwards as normal. If it is false, then and only then will we jump over the code.</p> <pre><code>title: For Illustration\nSee Devin Cook's Part 6 Lecture Slide, slide 26-28.\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#throw-a-wrench-in-the-works-with-an-else-clause","title":"Throw a Wrench in the Works With an Else Clause","text":"<p>We do similar logic as the plain <code>if</code> statement, except for the <code>false</code> case will jump to its own block, and we jump over the <code>false</code> block at the end of the <code>true</code> block (otherwise, assembly just executes instructions as they come and the '<code>false</code> block will be executed as well').</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#3-loops","title":"3. Loops","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#while-loops","title":"While Loops","text":"<p>We write <code>while</code> loops in assembly basically like <code>if</code> statements. To create a while statement: 1. Start with an If statement 2. Add an unconditional jump at the end of the block that jumps to the beginning The initial if statement will break the loop.</p> <pre><code>While:\n    cmp rdi, 21\n    jge End\n\n    #true block\n    jmp While\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#do-while-loops","title":"Do While Loops","text":"<p>A <code>while</code> loop implementation, but with a post test (will run at least once). <pre><code>Do:\n    #true block\n\n    cmp rdi, 21\n    jl Do\n</code></pre></p> <p>In this case, it actually costs us less LOC do use positive (straightforward logic) as compared to negative logic.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#4-best-friends-addressing-and-loops","title":"4. Best Friends: Addressing and Loops","text":"<p>In <code>for-each</code> loops in high level languages, we can use the index as a variable to access each element in an array. In assembly, we accomplish this by using a register to store the index. For example: <pre><code>.intel_syntax noprefix\n.data\nGreeting: \n    .ascii \"Hello\"\n\n.text\n.global _start:\n_start:\n\n    mov rdi, 0\n\nLoop:\n    cmp rdi, 4\n    jg End # end loop\n\n    movb [Greet + rdi], 33\n    add rdi, 1\n    jmp Loop\n End:\n     call Exit\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%206/Part%206%20-%20Control%20Logic/#5-switch-statements-on-x86-the-why-for-c-java-and-c","title":"5. Switch Statements on x86: The Why for C, Java, and C","text":"<p>The Switch behavior for C, Java, and C# is strange/peculiar in that they require break statements for each case of the switch, otherwise the execution falls through each of them. This is because for efficient and cast compilation to ASM, the ASM behavior is mapped almost one-to-one. For example: <pre><code>mov rdi, 13\ncmp rdi, 10 # equivalent of \"case 10:\" in C\nje case_10 # jump to handler\n\ncmp rdi, 11 # equivalent of \"case 11:\" in C\nje case_11 # jump to handler\n\njmp default # default case\n\ncase_10: # each of these \"falls through\" because we don't jump\n    call Handler10\ncase_11:\n    call Handler11\ndefault:\n    call Default\n</code></pre></p> <p>So, in C, Java, and C#, a <code>break</code> statement just maps to a jump statement. Thus, our handlers, with <code>break</code>s this time, would be written as: <pre><code>case_10: # now these cases are one-and-done\n    call Handler10\n    jmp End\ncase_11:\n    call Handler11\n    jmp End\ndefault:\n    call Default\n    jmp End\nEnd:\n    call Exit\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/","title":"Part 7   Arithmetic Logic Unit","text":"<p>Math!</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#1-adding-binary-numbers","title":"1. Adding Binary Numbers","text":"<p>Computers add binary numbers the same way that we add numbers in decimal format. They align columns, add, and carry over \"1\"s to the next column. This operation is completed by a processor component called the adder. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#negative-binary-numbers","title":"Negative Binary Numbers?","text":"<p>In the decimal system, we prefix negative numbers with a minus sign. However, computers can only store \"1\"s and \"0\"s, so we need some other way to store this marking. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#a-signed-magnitude","title":"A. Signed Magnitude","text":"<p>In this system, we use the most significant byte (MSB) to store this identification. \"0\" in the MSB indicates a positive number and \"1\" a negative number. Since this is identical to an unsigned number without context, it is up to the developer to indicated whether a number is signed or unsigned. </p> <p>The range of an 8-bit signed magnitude number is from -127 to 127.</p> <pre><code>title: 8-bit 13 &amp; -13 in Signed Magnitude\n\n13:\n&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n\n&amp;ensp;\n\n-13:\n&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n        &lt;td&gt;0&lt;/td&gt;\n        &lt;td&gt;1&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#disadvantages-of-signed-magnitude","title":"Disadvantages of Signed Magnitude","text":"<p>Signed magnitude accomplishes one goal, but introduces other problems. For one, it requires the system to check the sign bits each time (e.g., add if both are positive, subtract if one is negative, etc, etc). It also introduces positive and negative zero. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#b-1s-compliment","title":"B. 1s Compliment","text":"<p>1s compliment is built on top of the same idea as Signed Magnitude, i.e., \"0\" denotes a positive number and \"1\" a negative number. However, 1s Compliment accomplishes this by inverting each bit (0 \\(\\rightarrow\\) 1 and 1 \\(\\rightarrow\\) 0) to create the compliment of the original number. Logically, this is equivalent to subtracting the original number from 0. </p> <p>An 8-bit 1s Compliment number can range from -127 to 127.</p> <pre><code>title: 8-bit 13 and -13 in 1s Compliment\n\n13: \n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\n&amp;emsp; \n\n-13:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#advantages","title":"Advantages","text":"<p>This results in very simple rules for adding &amp; subtracting. Just simply add the numbers. 5 -3 is the same as 5 + (-3).</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#disadvantages","title":"Disadvantages","text":"<p>1s Compliment still results in positive and negative zero. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#c-2s-compliment","title":"C. 2s Compliment","text":"<p>2s Compliment is the final form of all of these strategies and is used by practically all modern computers. A 2s Compliment is created by inverting each bit and then adding +1 (same steps in either direction). This is logically equivalent to subtracting the number from \\(2^n\\), where \\(n\\) is the total number of bits in the integer. </p> <pre><code>title: 8-bit 13 and -13 in 2s Compliment\n\n13: \n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\n&amp;emsp; \n\n-13:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre> <p>The instruction for 2s Compliment negation on x86 is: <pre><code>NEG register\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#advantages_1","title":"Advantages","text":"<p>Once again, numbers can simply be added. In this addition, the extra carry \"1\" that may be left over at the end can be thrown away. This is great for hardware since the processor only needs to know how to add.</p> <p>Additionally, there is only one zero in this format and the range supports an additional integer (e.g. an 8-bit integer can range from -128 to 127).</p> <pre><code>title: Processors are dumb\n\nProcessors don't know and don't care whether a number is signed or unsigned; things will work either way. So, it is up to you to keep track (since instructions often vary depending on what kind of integer you are expecting)!\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#addition-and-subtraction-on-the-x86","title":"Addition and Subtraction on the x86","text":"<p>Both addition and subtraction take two operands and store the result in the first operand. The instructions for both are listed below:</p> <pre><code>ADD target, value\n# target is register or memory\n# value is immediate, register, or memory\n</code></pre> <pre><code>SUB target, value\n# target is register or memory\n# value is immediate, register, or memory\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#2-multiplication","title":"2. Multiplication","text":"<p>The processor really only knows how to add. Historically, processors have done multiplication using successive additions, e.g., \\(4 \\cdot 5\\) would add \\(5\\) together 4-times. This is an inefficient algorithm (not \\(O(1)\\)). So, nowadays computers do long multiplication just as we do in the decimal system. This fixes the number of addition to 8, 16, 32, or 64 depending on the size of the integers.</p> <pre><code>title: Unsigned, 4-bit addition. 13 * 10\n\n![Screenshot 2023-04-29 at 11.47.55 AM.png](&lt;./Screenshot 2023-04-29 at 11.47.55 AM.png&gt;)\n</code></pre> <pre><code>title: Muliplication Bit Count\n\nThe size of the product is 2x the original, e.g., 2 4-bit numbers multiplied will result in one 8-bit product.\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#multiplication-on-the-x86","title":"Multiplication on the x86","text":"<p>The unsigned instruction for multiplication on the x86 is: <pre><code>MUL operand\n\n# operand must be register or memory\n</code></pre></p> <p>and signed multiplication is: <pre><code>IMUL operand\n\n# operand must be register or memory\n</code></pre></p> <p>The first operand must be stored in <code>RAX</code> and the second operand must be provided from register or memory only. </p> <p>This operand, as discussed previously, has a product with double the bit size of its inputs. How do we store this result? It is often too large to fit into a single register. </p> <p> Multiplication on the x86 uses two registers: <code>RAX</code> for the lower 8 bytes and <code>RDX</code> for the upper 8 bytes in order to maintain precision. </p> <pre><code>Multiplication overwrites any data already existing in `RAX` or `RDX`, so it that data is important, BACK IT UP.\n</code></pre> <p>There are additionally \"short\" IMUL instructions that store the multiplication product of unsigned integers in one register, but that is beyond the scope of this course. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#3-extending-byte-size","title":"3. Extending Byte Size","text":"<p>We often find the need to extend, or move, data from smaller byte sizes to greater bit size, e.g. 8-bit to 16-bit. </p> <p>For unsigned numbers, this is easy. Just add more zeros on the left side, as we do with normal decimal numbers.</p> <p>For signed numbers, this doesn't work because simply adding zeroes will change a negative number to a positive number. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#a-extending-signed-magnitude","title":"A. Extending Signed Magnitude","text":"<ol> <li>Copy the old sign-bit (MSB) to the new sign-bit (new MSB)</li> <li>Fill the in-between with zeroes (and overwrite the old sign bit with one too)</li> </ol> <pre><code>title: Extending -77\nOld:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\nExtended:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#b-extending-2s-compliment","title":"B. Extending 2s Compliment","text":"<p>Only one rule: copy the old MSB to all the new bits. <pre><code>title: Extending -77 in 2s Compliment\nOld:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\nExtended:\n&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n    &lt;td&gt;0&lt;/td&gt;\n    &lt;td&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#4-division","title":"4. Division","text":"<p>Division is similar to multiplication. Division stores the input numerator in <code>RAX</code> (lower 8 bytes) and <code>RDX</code> (upper 8 bytes). The output is stored with the quotient (whole number) in <code>RAX</code> and the remainder in <code>RDX</code>.</p> <p>Unsigned: <pre><code>DIV denominator\n\n# denominator is register or memory ONLY\n</code></pre></p> <p>Signed: <pre><code>IDIV denominator\n\n# denominator is register or memory ONLY\n</code></pre></p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#division-rules","title":"Division Rules","text":"<ol> <li>The numerator must be sign-expanded to the destination size (2x the original), since division halves the number of bytes. This must be done before hand.</li> <li>We must setup RDX before division. For unsigned numbers, input 0. For signed numbers, RAX must be sign expanded into RDX. There are special instructions for this listed below:</li> </ol> <pre><code># 16 bit: Extends AX \u2192 into DX\nCWD # Convert Word Double\n\n# 32 bit: Extends EAX \u2192 into EDX\nCDQ # Convert Double Quad\n\n# 64 bit: Extend RAX \u2192 into RDX\nCQO #Convert Quad Oct\n</code></pre> <pre><code>title: 64-bit division -1846 by 42\n~~~asm6502\nMOV rax, -1846 #RAX is the dividend\nMOV rbx, 42 #Divisor\nCQO #Sign Extend dividend in RAX into RDX\nIDIV rbx #RAX gets the quotient and RDX the remainder\n~~~\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#5-comparison","title":"5. Comparison","text":"<p>It's basically just subtraction! The second argument is subtracted from the first.  - A - B = a positive number ? A was larger - A - B = a negative number ? B was larger - A - B = 0 ? Both are equal</p> <p>The result itself is thrown away. </p> <pre><code>CMP arg1, arg2\n#arg1 is register or memory\n#arg2 is immediate, register, memory\n</code></pre> <p>Ok, so if the result is thrown away, then what do we use after the comparison? We use flags, or boolean values stored as individual bits in the Status Register that indicate the result of the action.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#types-of-flags","title":"Types of Flags","text":"<ol> <li>Zero Flag (ZF): True if the last comparison resulted in zero (indicates equality)</li> <li>Sign Flag (SF): True if the MSB of the result is 1 (indicates a negative 2s Compliment number). Meaningless of the operands are interpreted as unsigned.</li> <li>Carry Flag: (CF): True if a 1 is \"borrowed\" in subtraction or \"carried\" in addition. In unsigned numbers this indicates overflow (too big) in addition or underflow (too small) in subtraction. </li> <li>Overflow Flag (OF): aka \"Signed Carry Flag\". True if the sign bit changed when it shouldn't have. Indicates overflow or underflow. </li> </ol>"},{"location":"CSUS/Fall%2023/CSC35/Part%207/Part%207%20-%20Arithmetic%20Logic%20Unit/#flags-in-context-of-jump-instructions","title":"Flags in Context of Jump Instructions","text":"<p>Equality:</p> Jump Description When True JE Equal ZF = 1 JNE Not Equal ZF = 0 <p>Signed Jump:</p> Jump Description When True JG Jump Greater than SF = OF, ZF = 0 JGE Jump Greater than or Equal SF = OF JL Jump Less than SF != OF, ZF = 0 JLE Jump Less than or Equal SF != 0 <p>Unsigned Jump:</p> Jump Description When True JA Jump Above CF = 0, ZF = 0 JAE Jump Above or Equal CF = 0 JB Jump Below CF = 1, ZF = 0 JBE Jump Below or Equal CF = 0"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/","title":"1. The System Stack: A Pile of Data","text":"<p>A Stack is a LIFO data structure introduced in CSC 20 and Java. Examples of stacks are: - Page-visited \"back-button\" history in a web browser - Undo sequence in a text editor - Deck of cards in Windows Solitaire A processor maintains its own stack in memory which stores integers the size of the bit-size of the system (e.g., a 64-bit system stores 64-bit integers on the stack). The stack allows for subroutines, a simpler version of functions in higher-level languages. The stack is defined in memory by a fixed location pointer (S0) locating the bottom and a stack pointer locating the top.,</p> <p>There are two approaches to working with the stack: 1. Growing Upwards: S0 is the lowest address in the stack buffer and the stack grows towards higher addresses 2. Growing Downwards: S0 is the highest address in the stack buffer and the stack grows towards lower addresses. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#size-of-the-stack","title":"Size of the Stack","text":"<p>As a data structure, stacks can be infinitely deep (unlimited data storage), but since they are implemented using memory buffers on processors (finite in size), if the data exceeds the allocated space, a stack overflow error occurs error occurs.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#2-subroutines-organizing-your-programs","title":"2. Subroutines: Organizing Your Programs","text":"<p>We cannot have subroutines without the stack since the stack is necessary in saving return addresses for call instructions, backing up and restoring registers, and passing data between subroutines. </p> <p>When we call a subroutine: 1. Processor pushes the IP on the stack 2. The IP is then set to the address of the subroutine 3. The subroutine executes and ends with a \"return\" instruction. 4. The processor pops and restores the original IP 5. Execution continues after the initial call</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#nesting-is-possible-subroutines-call-other-subroutines","title":"Nesting is Possible: Subroutines Call other Subroutines","text":"<p>Let's look at an example of a subroutine <code>f()</code>, which calls <code>g()</code>, which furthermore calls <code>h()</code>.</p> <p>What the stack does is it stores the return addresses of the callers (much like the history button in a web browser). As each subroutine completes, the processor pops the top of the stack and returns to the caller. </p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#a-x64-subroutines","title":"A. x64 Subroutines","text":"<pre><code>CALL address\n\n#address typically is made simpler with a label instead\n</code></pre> <p>The Call instruction transfers control to a subroutine (may be called JSR on other processors).  The Return instruction marks the end of a subroutine (do not forget - it often will cause your program to run beyond its end!).</p> <pre><code>RET #no arguments!\n</code></pre> <pre><code>title: Subroutine Example\n![Screenshot 2023-04-30 at 8.40.40 AM.png](&lt;./Screenshot 2023-04-30 at 8.40.40 AM.png&gt;)\n</code></pre>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#3-operating-systems-master-software","title":"3. Operating Systems: Master Software","text":"<p>An operating system is a series of programs with special privileges needed by the OS. There are two executing modes for programs on modern processors. </p> <ol> <li>Privileged Mode (Supervisor Mode): In this mode, programs can run special instructions and talk to all hardware</li> <li>User Mode: In this mode, programs can only execute certain instructions and are limited in their ability to talk to hardware.</li> </ol>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#a-vector-tables","title":"A. Vector Tables","text":"<p>Programs and hardware often need to talk to the OS (e.g., USB port notifying the OS, programs runs an OS function). To accomplish this, the processor can be interrupted (or alerted) that something must be handled. The processor then runs a special program to handle that event. </p> <p>During this interrupt, the device sends the processor a unique interrupt number that will then be looked up in a vector table, which contains the address of the Interrupt Service Routine (ISR) to execute for that event. </p> <p></p> <p>When the processor gets an interrupt: 1. Backs up the register file 2. Executes the ISR 3. Upon completion, restores the original executing program and register file</p> <p>The the ISRs belong to the kernel, or the core of the OS (the vast majority of which is hidden from the user). </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#3-interacting-with-applications-how-we-talk-to-the-os","title":"3. Interacting with Applications: How We Talk to the OS","text":"<p>Software also needs to talk to the OS, just like hardware (\"draw a button\", \"print a document\", etc, etc). There are interrupts specifically designated for software so that a running program can interrupt itself with a specific number. </p> <p>Programs \"talk\" to the OS with Application Program Interfaces (APIs). Application \\(\\rightarrow\\) OS \\(\\rightarrow\\) IO. This has the benefit of making applications faster and smaller and securing the system by abstracting away the IO from direct access by programs.</p> <p>The interrupt for programs in assembly is: <pre><code>SYSCALL\n</code></pre></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#subroutines-vs-interrupts","title":"Subroutines vs. Interrupts","text":""},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#4-linux-system-calls","title":"4. Linux System Calls","text":"<p>Linux also uses interrupts. Applications don't know where (in memory) to contact the kernel so they ask the processor to do it.</p> <p>How it works: 1. Fill the registers 2. Interrupt using <code>syscall</code> 3. Any results will be stored in the registers</p> <p>How to call: 1. The <code>rax</code> register must contain the syscall number (indicates to the OS what you are trying to do; there are only 329 total calls on a 64-bit UNIX system). 2. Other registers hold data in a rather odd order: <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code></p> <p>Some calls are listed below:</p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%208/Part%208%20-%20Subroutines%20and%20Operating%20Systems/#5-saving-registers-and-lost-data","title":"5. Saving Registers and Lost Data","text":"<p>There are limited number of registers and a lot of subroutines need to use (and often modify) registers, so variables we store may be changed. </p> <p>There are two solutions to this problem: 1. Caller saves values: The caller saves all their register to memory before making a subroutine call and restores them before continuing (not recursion friendly). 2. Subroutine saves values: Subroutine pushes registers onto the stack and pops (restores) the old values off the stack before it returns.</p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/","title":"1. von Neumann Architecture","text":"<p>Modern computers are based on the design of John von Neumann, who simplified the construction and use of computers.</p> <p>There are three main attributes to this architecture: 1. Programs are stored and executed in memory 2. Separation of processing from memory 3. Different system components communicate oven a shared bus</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#a-the-bus","title":"A. The Bus","text":"<p>The bus is an electronic pathway that transports data between components (kinda like a highway, data moves on shared paths). There are three categories/sets of signals on the memory bus: 1. address bus 2. data bus 3. control bus</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#address-bus","title":"Address Bus","text":"<p>This bus is used by the processor to access a specific piece of data. This \"address can be\": - a specific byte in memory - a unique IO port - etc The more bits it has, the more memory can be accessed.</p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#data-bus","title":"Data Bus","text":"<p>The actual data travels over the data bus. The number of bits that the processor uses (as its natural unit of data) is called a word. A system is typically defined by its word size. For example: - 8-bit system uses 8-bit words - 16-bit system uses 16 bits (2 bytes) words - 32-bit system uses 32 bits (4 bytes) words</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#control-bus","title":"Control Bus","text":"<p>The control bus controls the timing and synchronizes the subsystems. It Specifies what is happening, e.g., read data, write data, reset, etc, etc. </p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#b-von-neumann-architecture-today","title":"B. von Neumann Architecture Today","text":"<p>Most modern systems use a modified version of his design. In particular, they have a special high-speed bus between the processor/memory (like an HOV lane or high-speed rail; fixed source and destination and goes faster than the freeway).</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#2-the-system-clock","title":"2. The System Clock","text":"<p>The rate at which instructions are executed are controlled by the CPU clock. The faster the clock rate, the faster instructions will be executed. This is measured in Herts (Hz), the number of oscillations per second. Computers are typically labeled on the processor's clock rate.</p> <p>Not all instructions are equal in execution time: some will require many cycles to execute.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#3-technological-trends","title":"3. Technological Trends","text":"<p>Since the design of the integrated circuit (IC), computers have advanced dramatically. Integrated circuits have improved in: - Density: the total number of transistors and wires placed in a fixed area on a silicon chip.  - Speed: How quickly basic logic gates and memory devices operate. - Area: the physical size of the largest integrated circuit that can be fabricated. </p> <p>The rate of improvement, which is exponential rather than linear, has been described by Moore's Law for the past 50 years: performance doubles every 18 months.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#4-computer-architectures","title":"4. Computer Architectures","text":"<p>Computer architecture is often a contentious debate, which many issues, such as: - how memory should be accessed - what instructions are needed - how are instructions to be encoded.</p> <p>Typically, this debate is dominated by CISC vs. RISC, although very rarely is any one processor purely one or the other. </p> <p>It's all a balance of hardware vs. software.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#i-risc","title":"I. RISC","text":"<p>Reduced Instruction Set Computer (RISC). This emphasizes simplicity in hardware and more complexity in software. RISC will contain fewer instructions (the bare minimum needed to work) with limited memory access (often just register load and store). Thus, this architecture will also have many more registers.</p> <p>Instructions will tend to take only one cylce each and the number of bytes used by instructions tend to be fixed in size. </p> <p>Advantages:  - simpler instructions simplify hardware (easy to manufacture) - less to learn and master - less heat produced and less energy required - memory access is minimized</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#ii-cisc","title":"II. CISC","text":"<p>Complex Instruction Set Computer (CISC) emphasizes flexability in instructions; hardware bears the burnt of complexity. Instructions can take multiple clocks and operands are generalized - each can access memory, immediates, and registers.</p> <p>This architecture features fewer general purpose registers and instruction bit sizes vary. </p> <p>This requires fewer instructions than RISC for the same computation and software is easier to write within the flexibility.</p> <p>Advantages: - programs written tend to take less space in memory - varied size instructions can make it possible for the processor to evolve: add new instructions</p> <p></p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#5-instruction-operands","title":"5. Instruction Operands","text":"<p>The number of instruction operands varies based on processor. More operands means more functionality, but come at the cost of having to store more bits in memory. Processors typically support either 1, 2, or 3 operands. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#i-single","title":"I. Single","text":"<p>Single operand processors are known as accumulators. These use the accumulator register for all mathematical operations and other registers are simply used for comparison and to store temp data.</p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#ii-double","title":"II. Double","text":"<p>Two operand processors allow two operands to be specified. Both are typically treated as input and one is used to store the result. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#iii-make-it-triple","title":"III. Make it Triple","text":"<p>Three operand processors can specify a third output operand to be used as an index for simple addressing or for other uses. </p>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#6-instruction-execution","title":"6. Instruction Execution","text":"<p>Instruction execution can be broken down into 5 steps:</p> <ol> <li>Fetch: The processor fetches the instruction from memory and stores it in the IR.</li> <li>Decode: The instruction is decoded to determine what it is and its operands. Signals are sent to the EU as input. </li> <li>Read: EU reads the values of the instruction.</li> <li>Execute: Values are passed to the ALU to act upon. </li> <li>Write: The result is written into register/memory. Processor also updates the flags and other state information such as the IP.</li> </ol>"},{"location":"CSUS/Fall%2023/CSC35/Part%209/Part%209A%20-%20Design%20Principles/#i-pipelining","title":"I. Pipelining","text":"<p>Doing two instructions consecutively is cumbersome and inefficient. We can use pipelining to execute instructions simultaneously. This is implemented solely in hardware and is different from multi-core processors: it only happens on a single core. </p> <p>On modern processors, practically all the hardware is in continuous use via pipelining.</p> <p>In pipelining, the speedup is directly proportional to the number of steps that we can do in parallel. As the number of loads increase, the start-up and wind-down costs (where the pipeline isn't completely full) lower.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/","title":"Chapter 10 Reading Notes","text":"<p>Interactions and Potential Energy.</p> <p>In chapter 9, we covered the idea of external forces in the environment doing work on a system. In in this chapter, we will discuss forces and work internal to the system.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#potential-energy","title":"Potential Energy","text":"<p>Systems are merely a tool for analysis, not an actual, real thing. We can define systems as we please. In the following example, \\(System_{1}\\) is defined such that there is external \\(W\\) (by the spring) on the system. In this case, the applicable energy principle equation is: $$ \\Delta S_{sys 1} = \\Delta K_{tot} = \\Delta K_{A} + \\Delta K_{B} = W_{A} + W_{B} \\tag{10.1}$$ meaning that the \\(E_{sys 1}\\) is completely defined by the \\(K_{tot}\\).  \\(System_{2}\\) does not have an external interaction with the environment; rather, it has an internal environment. So, the total Work \\(W\\) on the system is 0.. The \\(E_{sys 2}\\) is \\(K_{tot} + U\\) (potential energy). We then revise Equation 10.1 as:      $$ \\Delta E_{sys 2} = \\Delta K_{tot} + \\Delta U = (W_{A} + W_{B}) + \\Delta U = 0 \\tag{10.2}$$     In other words,      $$ \\Delta U = -(W_{A} + W_{B}) = - W_{internal} \\tag{10.3}$$ For Kinetic Energy gained within this system, the exact same amount of potential energy is \"lost\", or rather, converted (since energy is conserved). </p> <p> TL;DR Restricted system of only the particles is just kinetic energy. If the system includes the interaction, it has both potential and kinetic energy. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#i-gravitational-potential","title":"I.  Gravitational Potential","text":"<p>When we include the earth in a system involving a particle falling, we can define potential energy like so  $$ \\Delta U_{G} = -(W_{OnParticleByGravity} + W_{onEarthByGravity}) \\tag{10.4} $$ Since \\(W = \\vec F \\cdot \\vec \\Delta d\\), \\(W_{OnEarthByGravity}\\) is functionally zero, it can be excluded from the equation. If we define the final position (or even the initial) of the falling particle to be \\(y=0\\), then the Gravitational Potential Energy of the particle is  $$ \\Delta U_{G} = mgy \\tag{10.5} $$</p> <p>Stay consistent in choosing the zero for \\(y\\)!</p> <p>Law of Conservation of Energy: \\(E_{mech \\&gt; i} = E_{mech \\&gt; f} \\rightarrow K_{i} + U_{G i} = K_{f} + U_{G f}\\) </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#a-gravitational-potential-beyond-vertical-free-fall","title":"A. Gravitational Potential Beyond Vertical Free Fall","text":"<p>\\(\\Delta U_{G}\\) is solely dependent on an objet's vertical displacement since \\(F_{G}\\) does not have a horizontal component (given in a standard \\(x\\)-\\(y\\) plane). This similarly applies to </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#b-u_g-and-f_friction","title":"B. \\(U_{G}\\) and \\(F_{friction}\\)","text":"<p>Friction always makes a surface hotter (never colder), it adds to thermal energy of the system and \\(E_{mech \\&gt; f} &lt; E_{mech \\&gt; i}\\).  $$ K_{i} + U_{G &gt; i} = K_{f} + U_{G &gt; f} + \\Delta E_{th} \\tag{10.6} $$ System energy is still conserved. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#elastic-potential","title":"Elastic Potential","text":"<p>Much of the concepts of \\(U_{G}\\) carries over to Elastic Potential Energy in springs. \\(\\Delta U_{Sp} = - (W_{ByBlockOnSpring} + W_{OnWallBySpring})\\) But, once again, the wall has no displacement, thus, actually: $$ \\Delta U_{Sp} = -W_{ByBlockOnSpring} \\tag{10.7} $$ With the equation for Work by a spring in the previous section (derived by integration): $$ U_{Sp} = \\frac{1}{2}k(\\Delta s)^2 \\tag{10.8} $$</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#a-with-gravity","title":"A. With Gravity","text":"\\[U_{tot} = U_{G} + U_{sp} \\tag{10.9}\\]"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#conservation-of-energy","title":"Conservation of Energy","text":"<p>Energy is conserved in an isolated system (no external interactions with the environment).</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#energy-diagrams","title":"Energy Diagrams","text":"<p>Energy vs. position, with both \\(E_{tot}\\) and \\(U\\) graphed. </p> <p></p> <p>A minimum point on the PE curve is a point of stable equilibrium, where small disturbances cause small oscillations. </p> <p>A maximum point on the PE curve is a point of unstable equilibrium, where small disturbances cause a particle to move away. </p> <p>Strategies:  1. Distance from -axis to PE curve is the PE of the system. KE is the distance from PE to TE.  2. A point where the TE line crosses the PE curve is a turning point (the particle reverses direction). 3. PE cannot be above TE. 4. PE cannot be changed (dependent on mass, spring constant, etc, etc). TE can be changed via initial conditions.  5. PE curve min is stable equilibrium, a max is unstable equilibrium. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#force-and-potential-energy","title":"Force and Potential Energy","text":"<p>\\(\\(F_{s} = -\\frac{\\Delta U}{\\Delta s} = \\lim_{x \\to \\infty} (-\\frac{\\Delta U}{\\Delta s}) = -\\frac{dU}{ds} \\tag{10.10}\\)\\) or in other words, \\(F_{s}\\) , is the negative of the slope of the PE curve. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2010/Chapter%2010%20Reading%20Notes/#conservative-and-nonconservative-forces","title":"Conservative and Nonconservative Forces","text":"<p>Why do we have gravitational potential energy, for example, and not tensional or frictional potential energy?</p> <p>A force for which the work done on a particle as it moves from point A to point B, regardless of the path taken, is a conservative force. Any potential energy can be associated why any conservative force. We use conservative because mechanical energy is conserved.     - In other words, an object returning to its original position will suffer no loss of mechanical energy.</p> <p>A force for which we cannot define a potential energy is a nonconservative force. For example, friction is nonconservative because KE is converted to Thermal Energy and thus there is a loss in KE.      - Most forces are not conservative forces. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/","title":"1. Momentum and Impulse: An Introduction","text":""},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#momentum","title":"Momentum","text":"<p>When objects collide, they are not like particles; they deform. When they collide, the object is more like an elastic object that compresses (storing elastic potential energy) and then expanding and rebounding into the opposite direction (transforming that PE into KE). </p> <p>This change can be modeled using Newton's Second Law: \\(m \\vec a = m \\frac{d \\vec v}{dt} = \\vec F(t)\\). Further extrapolating this, we get the equation of momentum: $$ \\vec p = m \\vec v \\tag{11.1} $$ in units of kg m/s.</p> <pre><code>title: Sign of P\n\nThe momentum is parallel to the velocity vector and has the same sign as velocity.\n</code></pre> <p>Newton's Second Law is actually, originally written in terms of momentum, i.e., \\(\\vec F = \\frac{d \\vec p}{dt}\\). </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#impulse","title":"Impulse","text":"<p>Impulse is the change in momentum, or the time integral of the force: $$ \\vec J = \\int_{t_{i}}^{t_{f}}  \\vec F(t) \\, dt = \\Delta \\vec p \\tag{11.2} $$ In words, this is the moment principle, or the idea that an impulse delivered to an object causes a change in momentum.  $$ \\vec p_{f} = \\vec p_{i} + \\vec J $$</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#energy-and-impulse","title":"Energy and Impulse","text":"<p>The energy principle, covered in Chapter 9 Reading Notes, is as follows: $$ \\Delta K = W = \\int_{x_{i}}^{x_{f}}  F_{x} \\, dx $$</p> <p>Note that this equation is very similar to the equation for the moment principle. The only difference is that this is integrated with respect to position, rather than time.</p> <p>It is important to note that a Force does not do only one or the other: it provides both an impulse and work. You will use either equation depending on the question. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#conservation-of-momentum","title":"Conservation of Momentum","text":"<p>In an isolated system (no interaction or external force from the environment), the total momentum is conserved, i.e., $$ \\vec P_{f} = \\vec P_{i} \\tag{11.3} $$ or in other words, $$ (p_{fx}){1} + (p{fx}){2} + ... = (p{ix}){1} + (p{ix})_{2} + ...  $$</p> <pre><code>title: Choose the Right System\n\nMomentum is only conserved in an isolated system. This means that you must be careful in choosing the right system.\n</code></pre>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#2-collisions","title":"2. Collisions","text":""},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#inelastic-collisions","title":"Inelastic Collisions","text":"<p>An inelastic collision occurs when two objects collide, stick together, and then move with a common final velocity. In this collision, total momentum is conserved, but mechanical energy is not (since some KE is transformed into thermal energy).</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#elastic-collisions","title":"Elastic Collisions","text":"<p>An elastic collision occurs when two objects collide, and then perfectly bounce off each other (all energy is conserved). Total momentum and mechanical energy is conserved.  </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#reference-frames","title":"Reference Frames","text":"<p>See Textbook Chapter 11.3.3</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#3-explosions","title":"3. Explosions","text":"<p>An explosion is the opposite of a collision. The particles of a system move apart from each other after a brief, intense interaction. The explosive forces that cause this explosion are internal forces, an if the system is properly isolated, then total momentum will be conserved. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#4-momentum-in-2d","title":"4. Momentum in 2D","text":"<p>Momentum can be expanded into 2D with \\(x\\)- and \\(y\\)- components. As shown in Equation 11.3 in #2. Collisions. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%2011/Chapter%2011%20-%20Impulse%20and%20Momentum/#5-rocket-propulsion","title":"5. Rocket Propulsion","text":"<p>\\(F_{thrust} = v_{ex}R\\) </p> <p>Don't worry too much about this. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/","title":"Chapter 8 Reading Notes","text":"<p>Dynamics Part II: Motion in Two Dimensions </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#dynamics-in-two-dimensions","title":"Dynamics in Two Dimensions","text":"<p>Newton's Second Law, \\(\\vec a = \\frac{\\vec F_{net}}{m}\\) does not differentiate between linear and 2D Motion and thus applies to both. Be very careful about the co-ordinate system chosen for each problem.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#projectile-motion-drag","title":"Projectile Motion &amp; Drag","text":"<p>We can ignore the effects of drag for objects of higher-mass, but this effect cannot be ignored for objects of low-mass. $$a_{x} = - \\frac{\u03d1  C_{d} A}{2m}v_{x}\\sqrt{v_{x}2+v_{y}2} $$ $$a_{x} = -g - \\frac{\u03d1 C_{d} A}{2m}v_{x}\\sqrt{v_{x}2+v_{y}2} $$</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#uniform-circular-motion","title":"Uniform Circular Motion","text":"<p>Dynamics: How forces cause motion.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#review","title":"Review","text":"<p>A particle in circular motion has a velocity tangent to the circle which is caused by the centripetal acceleration that points to the center.  \\(v = \\omega r\\) \\(\\rightarrow\\) \\(\\vec a = \\frac{v^2}{r} = \\omega^2 r\\) </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#x-y-axis-bad","title":"X-Y Axis Bad","text":"<p>Use RTZ-axes, where: 1. r-axis (radial axis) points from the particle towards the center. 2. t-axis (tangential axis) is tangent to the circle (points counter-clockwise) 3. z-axis is perpendicular to the plane of motion</p> <p>In the RTZ system, the following components of \\(\\vec v\\) and \\(\\vec a\\) are: - \\(\\vec v\\): \\(v_{r} = 0, v_{t} = \\omega r, v_{z} = 0\\) - \\(\\vec a\\): \\(a_{r} = \\frac{v^2}{r} = \\omega^2 r, a_{t} = 0, a_{z} = 0\\)  In UCM, velocity is only tangential and acceleration is only radial. </p> <p>The RTZ Axis is not an inertial reference frame because it rotates as it moves with the particle (so we don't make measurements in this frame).</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#ucm-dynamics-center-force-model","title":"UCM Dynamics &amp; Center-Force Model","text":"<p>\\(\\vec F_{net} = m \\vec a = \\frac{mv^2}{r}\\)  There is always a net Force towards the center. (Even at constant speed). Or in RTZ form: \\(\\((F_{net})_{r} = \\Sigma F_{r} = ma_{r} = \\frac{mv^2}{r} = m \\omega^2 r\\)\\) \\(\\((F_{net})_{t} = \\Sigma F_{t} = ma_{t} = 0\\)\\) $$(F_{net}){z} = \\Sigma F{z} = ma_{z} = 0 $$</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#circular-orbits","title":"Circular Orbits","text":"<p>Objects in Orbit are just constantly in free-fall as they keep falling to the ground but the ground keeps curving away (they need to \"catch up\"). At a sufficient launch angle, they curve of trajectory and the curve of the spherical \"planet\" are parallel meaning that even constantly falling, the object doesn't get any closer to the ground (Orbit).</p> <p>Gravity is the central force causing centripetal acceleration. \\(\\vec F_{G} = mg\\) towards the center of the planet.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#satellites","title":"Satellites","text":"<p>Period of satellite orbit: \\(T = \\frac{2\\pi r}{v_{orbit}} = 2\\pi\\sqrt{\\frac{r}{g}}\\)  Because objects in orbit are in free-fall, they are weightless. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#circular-motion-reasoning","title":"Circular Motion Reasoning","text":""},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#centrifugal-force-is-completely-false","title":"Centrifugal Force is Completely False","text":"<p>There is no such thing as a Centrifugal Force or a force that seems to push an object outside of a circle. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#bucket-and-water","title":"Bucket and Water","text":"<p>At the very bottom: \\(\\vec F_{c} = \\vec n\\), so \\(n &gt; F_{G}\\) such that: \\(n = mg + \\frac{m(v_{bot})^2}{r}\\)  At the very top, both \\(\\vec n\\) and \\(F_{G}\\) point towards the bottom. \\(\\Sigma F_{r} = n + mg = \\frac {m(v_{top})^2}{r}\\)  such that \\(n = \\frac {m(v_{top})^2}{r} - mg\\). At a low enough speed, the critical speed, there is a point where the cart has no contact with the cart and gravity itself is enough for the cart to complete the circle. That speed is calculated such that: $$ v_{c} = \\sqrt{\\frac{rmg}{m}} = \\sqrt{rg} $$ If the cart is moving at a speed \\(v &lt; v_{c}\\) , the calculated value for \\(n\\) would be negative, but realistically this means that the cart goes flying off.</p> <p>Back to the bucket of water, so long as \\(v \\ge v_{c}\\) there is a normal force of the bucket on the water enough to keep the water in the bucket. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%208/Chapter%208%20Reading%20Notes/#nonuniform-circular-motion","title":"Nonuniform Circular Motion","text":"<p>Circular motion with speed changes. The particle with changing speed also experiences a tangential force \\((F_{net})_{t}\\) so that there is an \\(a_{t} = \\frac {dv_{t}}{dt}\\). This force is positive when ccw and negative when cw.  \\(\\((F_{net})_{r} = \\Sigma F_{r} = ma_{r} = \\frac{mv^2}{r} = m \\omega^2 r\\)\\) \\(\\((F_{net})_{t} = \\Sigma F_{t} = ma_{t}\\)\\) $$(F_{net}){z} = \\Sigma F{z} = ma_{z} = 0 $$ If \\((F_{net})_{t}\\) is constant, we can use constant-acceleration kinematics. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/","title":"Chapter 9 Reading Notes","text":"<p>Introduction to the Basic Energy Model. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#intro-to-energy","title":"Intro to Energy","text":"<p>Energy is measured in J (joules)</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#potential-energy-u","title":"Potential Energy (U)","text":"<p>Energy associated with an object's position, i.e., how an object's position gives it (or takes away) from it's energy</p> <p>Example: Gravitational potential \\(U_{g}\\) depends on the object's height above the ground</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#kinetic-energy-ke","title":"Kinetic Energy (KE)","text":"<p>Energy associated with an object's motion, i.e., how much energy is in it's motion within a system.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#thermal-energye_th","title":"Thermal Energy(\\(E_{th}\\))","text":"<p>Energy associated with the random motion of atoms within an Object</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#what-is-work","title":"What is Work?","text":"<p>Work is the change in the energy within a system by mechanical means, e.g., pushing or pulling (a Force). If there is no displacement, there is no Work.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#the-energy-of-a-system","title":"The Energy of a System","text":"<p>the total energy of a system is defined as $$E_{total} = KE + U + E_{th} + E_{chem} + ... $$</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#the-energy-principle","title":"The Energy Principle","text":"\\[\\Delta E_{sys}=W_{external}\\]"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#conservation-of-energy-energy-transformation","title":"Conservation of Energy: Energy Transformation","text":"<p>Systems have energy, so it is imperative to correctly define a system. This is important because energy is conserved within a system - transfer without loss - as long as there is no external force from the environment. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#interactions-with-the-environment-energy-transfer","title":"Interactions with the Environment: Energy Transfer","text":"<p>Interactions with the environment transfer energy into or out of systems. There are two forms of this transfer 1. Mechanical: pull or push forces transfer energy. Called Work \\(W&gt;0\\) when for energy added to a system      \\(W &lt; 0\\) for removed energy.  2. Thermal: energy is transferred as heat. </p> <p>The Basic Energy model is only valid as long as there is no thermal transfer of energy. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#work-and-kinetic-energy-for-a-single-particle","title":"Work and Kinetic Energy for a Single Particle","text":""},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#basic-equations","title":"Basic Equations","text":"<p>\\(KE= \\frac{1}{2} mv^2\\), Units \\(kg\\&gt; m^2/s^2\\) </p> <p>\\(W=\\Delta KE=\\int_{s_{i}}^{s_{f}} F_{s} \\, dx\\)</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#signs-of-work","title":"Signs of Work","text":"<p>Remember that work is an energy transfer. If the force is causing a speed up, then Work done is positive (and vice versa for the slow-down/negative case).</p> <p>The sign of Work is not determined solely. by the direction of the force vector. The displacement \\(\\Delta s\\) also has a sign. </p> <p>\\(Force \\rightarrow\\) and \\(\\Delta s \\rightarrow\\) means positive Work. \\(Force \\leftarrow\\) and \\(\\Delta s \\rightarrow\\) is negative Work.</p> <p>A Force perpendicular to the displacement does no work.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#calculating-work-done","title":"Calculating Work Done","text":""},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#dot-products-a-way-of-multiplying-vectors","title":"Dot Products: A Way of Multiplying Vectors","text":"<p>\\(\\(\\vec A \\cdot \\vec B = ABcos\\theta = A_{x}B_{x}  + A_{y}B_{y}\\)\\)  AKA Scalar Product since this value is a Scalar.  The dot product is dependent on the orientation of the vectors. </p> <p>Work is actually also a dot product: \\(W = \\vec F \\cdot \\Delta \\vec r\\)</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#zero-work","title":"Zero Work","text":"<p>See skater on a wall example, chapter 9.3.4</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#variable-force","title":"Variable Force","text":"<p>\\(W=\\int_{s_{i}}^{s_{f}} F_{s} \\, dx\\)</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#restoring-forces-and-springs","title":"Restoring Forces and Springs","text":"<p>Restoring Force: a Force that restores a system to equilibrium, e.g., stretching a rubber band. Elastic objects are those objects that exert restoring forces; Nearly everything that stretches, compresses, bends, flexes, or twists.</p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#springs","title":"Springs","text":"<p>Equilibrium Length is the length of the spring when there is no push or pull. Restoring forces on springs are opposite to \\(\\Delta s\\) and within a certain limit, \\(F_{s} \\propto \\Delta s\\) </p> <p>Hooke's Law: \\(F_{s} = -k \\&gt; \\Delta s\\) , where \\(k\\) is the spring constant (Units: \\(\\frac{N}{m}\\)) Hooke's Law fails when a spring is compressed/stretched too far. Only works for \"ideal\" springs. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#work-done-by-springs","title":"Work done by Springs","text":"<p>\\(W=\\int_{s_{i}}^{s_{f}} F_{s} \\, ds = -(\\frac{1}{2} k \\&gt; (\\Delta s_{f})^2 - \\frac{1}{2} k (\\Delta s_{i})^2)\\) </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#dissipative-forces-and-thermal-energy","title":"Dissipative Forces and Thermal Energy","text":"<p>Atoms are constantly moving around and have kinetic energy. This movement stretches and compresses the spring-like bonds between atoms. The complete total of these atom movements and their combined \\(KE\\) and \\(U\\) Energies is the thermal energy of the system. </p> <p>Friction, drag, and other forces cause the macroscopic \\(KE\\) of the system to be dissipated as thermal energy. These dissipative forces always increase the thermal energy of a system. </p> <p>*Friction cannot be used to calculate work since it is the average force on the whole object. </p>"},{"location":"CSUS/Fall%2023/Phys11A/Chapter%209/Chapter%209%20Reading%20Notes/#power","title":"Power","text":"<p>Power is the rate at which energy is transformed. \\(P = \\frac{d\\&gt;E_{sys}}{d\\&gt;t}\\) . The units of power are:         1 t     horsepower (hp) = 746 \\(W\\) Where Watt (W) is the SI unit for power such that 1 watt = 1 \\(W\\) = 1 \\(J / s\\) . $$ P = \\vec F \\cdot \\vec v = Fv&gt;cos\\theta$$</p>"}]}